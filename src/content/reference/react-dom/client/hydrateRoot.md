---
title: hydrateRoot
translators:
  - childrentime
---

<Intro>

`hydrateRoot` å‡½æ•°å…è®¸ä½ åœ¨å…ˆå‰ç”± [`react-dom/server`](/reference/react-dom/server) ç”Ÿæˆçš„æµè§ˆå™¨ HTML DOM èŠ‚ç‚¹ä¸­å±•ç¤º React ç»„ä»¶ã€‚

```js
const root = hydrateRoot(domNode, reactNode, options?)
```

</Intro>

<InlineToc />

---

## å‚è€ƒ {/*reference*/}

### `hydrateRoot(domNode, reactNode, options?)` {/*hydrateroot*/}

ç”¨ `hydrateRoot` å‡½æ•°å°† React è¿æ¥åˆ°ç”± React åœ¨æœåŠ¡ç«¯ç¯å¢ƒä¸­æ¸²æŸ“çš„ç°æœ‰ HTML ä¸­ã€‚

```js
import { hydrateRoot } from 'react-dom/client';

const domNode = document.getElementById('root');
const root = hydrateRoot(domNode, reactNode);
```

React å°†ä¼šè¿æ¥åˆ°å†…éƒ¨æœ‰ `domNode` çš„ HTML ä¸Šï¼Œç„¶åæ¥ç®¡å…¶ä¸­çš„ `domNode`ã€‚ä¸€ä¸ªå®Œå…¨ç”± React æ„å»ºçš„åº”ç”¨åªä¼šåœ¨å…¶æ ¹ç»„ä»¶ä¸­è°ƒç”¨ä¸€æ¬¡ `hydrateRoot` æ–¹æ³•ã€‚

[è¯·å‚è§ä¸‹é¢æ›´å¤šç¤ºä¾‹](#usage)ã€‚

#### å‚æ•° {/*parameters*/}

* `domNode`ï¼šä¸€ä¸ªåœ¨æœåŠ¡å™¨ç«¯æ¸²æŸ“æ—¶å‘ˆç°ä¸ºæ ¹å…ƒç´ çš„ [DOM å…ƒç´ ](https://developer.mozilla.org/zh-CN/docs/Web/API/Element)ã€‚

* `reactNode`ï¼šç”¨äºæ¸²æŸ“å·²å­˜åœ¨ HTML çš„â€œReact èŠ‚ç‚¹â€ã€‚è¿™ä¸ªèŠ‚ç‚¹é€šå¸¸æ˜¯ä¸€äº›ç±»ä¼¼äº `<App />` çš„ JSXï¼Œå®ƒä¼šåœ¨ `ReactDOM Server` ç«¯ä½¿ç”¨ç±»ä¼¼äº `renderToPipeableStream(<App />)` çš„æ–¹æ³•è¿›è¡Œæ¸²æŸ“ã€‚

* **å¯é€‰**  `options`ï¼šä¸€ä¸ªåŒ…å«æ­¤ React æ ¹å…ƒç´ é€‰é¡¹çš„å¯¹è±¡ã€‚

  * **optional** `onCaughtError`: Callback called when React catches an error in an Error Boundary. Called with the `error` caught by the Error Boundary, and an `errorInfo` object containing the `componentStack`.
  * **optional** `onUncaughtError`: Callback called when an error is thrown and not caught by an Error Boundary. Called with the `error` that was thrown and an `errorInfo` object containing the `componentStack`.
  * **optional** `onRecoverableError`: Callback called when React automatically recovers from errors. Called with the `error` React throws, and an `errorInfo` object containing the `componentStack`. Some recoverable errors may include the original error cause as `error.cause`.
  * **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server.


#### è¿”å›å€¼ {/*returns*/}

`hydrateRoot` è¿”å›ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªæ–¹æ³•çš„å¯¹è±¡ [`render`](#root-render) å’Œ [`unmount`](#root-unmount)ã€‚

#### è­¦å‘Š {/*caveats*/}

* `hydrateRoot()` æœŸæœ›æ¸²æŸ“å†…å®¹ä¸æœåŠ¡ç«¯æ¸²æŸ“çš„å†…å®¹å®Œå…¨ç›¸åŒã€‚ä½ åº”è¯¥å°†ä¸åŒ¹é…è§†ä¸ºé”™è¯¯å¹¶è¿›è¡Œä¿®å¤ã€‚
* åœ¨å¼€å‘æ¨¡å¼ä¸‹ï¼ŒReact ä¼šåœ¨æ¿€æ´»æœŸé—´å‘å‡ºä¸åŒ¹é…è­¦å‘Šã€‚åœ¨ä¸åŒ¹é…çš„æƒ…å†µä¸‹ï¼Œä¸èƒ½ä¿è¯å†…å®¹å·®å¼‚ä¼šè¢«ä¿®è¡¥ã€‚å‡ºäºæ€§èƒ½åŸå› ï¼Œè¿™å¾ˆé‡è¦ï¼Œå› ä¸ºåœ¨å¤§å¤šæ•°åº”ç”¨ç¨‹åºä¸­ï¼Œä¸åŒ¹é…å¾ˆå°‘è§ï¼Œå› æ­¤éªŒè¯æ‰€æœ‰æ ‡è®°å°†æ˜¯æ˜‚è´µè€Œä¸å¯è¡Œçš„ã€‚
* ä½ çš„åº”ç”¨ç¨‹åºå¯èƒ½åªæœ‰ä¸€ä¸ª `hydrateRoot()` å‡½æ•°è°ƒç”¨ã€‚å¦‚æœä½ ä½¿ç”¨æ¡†æ¶ï¼Œåˆ™å¯èƒ½ä¼šä¸ºä½ å®Œæˆæ­¤è°ƒç”¨ã€‚
* å¦‚æœä½ çš„åº”ç”¨ç¨‹åºæ˜¯å®¢æˆ·ç«¯æ¸²æŸ“ï¼Œå¹¶ä¸”æ²¡æœ‰å·²æ¸²æŸ“å¥½çš„ HTMLï¼Œåˆ™ä¸æ”¯æŒä½¿ç”¨ `hydrateRoot()`ã€‚è¯·æ”¹ç”¨ [`createRoot()`](/reference/react-dom/client/createRoot)ã€‚

---

### `root.render(reactNode)` {/*root-render*/}

ä½¿ç”¨ `root.render` æ›´æ–°ä¸€ä¸ªæ¿€æ´»æ ¹ç»„ä»¶ä¸­çš„ React ç»„ä»¶æ¥æ¸²æŸ“æµè§ˆå™¨ç«¯ DOM å…ƒç´ ã€‚

```js
root.render(<App />);
```

React å°†ä¼šåœ¨æ¿€æ´» `root` ä¸­æ›´æ–° `<App />`ã€‚

[å‚è§ä¸‹é¢æ›´å¤šç¤ºä¾‹](#usage)ã€‚

#### å‚æ•° {/*root-render-parameters*/}

* `reactNode`ï¼šä½ æƒ³è¦æ›´æ–°çš„ "React èŠ‚ç‚¹"ã€‚é€šå¸¸è¿™ä¼šæ˜¯ä¸€æ®µJSXä»£ç ï¼Œä¾‹å¦‚ `<App />`ï¼Œä½†ä½ ä¹Ÿå¯ä»¥ä¼ é€’ä¸€ä¸ªé€šè¿‡ [`createElement()`](/reference/react/createElement) åˆ›å»ºçš„ React å…ƒç´ ï¼Œä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä¸€ä¸ªæ•°å­—ï¼Œ`null` å€¼ æˆ–è€… `undefined` å€¼ã€‚


#### è¿”å›å€¼ {/*root-render-returns*/}

`root.render` è¿”å› `undefined` å€¼ã€‚

#### è­¦å‘Š {/*root-render-caveats*/}

* å¦‚æœä½ åœ¨æ ¹èŠ‚ç‚¹è¿˜æ²¡æœ‰å®Œæˆæ¿€æ´»çš„æƒ…å†µä¸‹è°ƒç”¨äº† `root.render`ï¼ŒReact å°†æ¸…é™¤ç°æœ‰çš„æœåŠ¡ç«¯æ¸²æŸ“ HTML å†…å®¹ï¼Œå¹¶å°†æ•´ä¸ªæ ¹èŠ‚ç‚¹åˆ‡æ¢åˆ°å®¢æˆ·ç«¯æ¸²æŸ“ã€‚

---

### `root.unmount()` {/*root-unmount*/}

è°ƒç”¨ `root.unmount` æ¥é”€æ¯ React æ ¹èŠ‚ç‚¹å†…çš„æ¸²æŸ“æ ‘ã€‚

```js
root.unmount();
```

å®Œå…¨ä½¿ç”¨ React æ„å»ºçš„åº”ç”¨é€šå¸¸ä¸ä¼šæœ‰ä»»ä½•è°ƒç”¨ `root.unmount` çš„æƒ…å†µã€‚

è¿™ä¸»è¦é€‚ç”¨äº React æ ¹èŠ‚ç‚¹çš„ DOM èŠ‚ç‚¹ï¼ˆæˆ–å…¶ä»»ä½•ç¥–å…ˆèŠ‚ç‚¹ï¼‰å¯èƒ½ä¼šè¢«å…¶ä»–ä»£ç ä» DOM ä¸­ç§»é™¤çš„æƒ…å†µã€‚ä¾‹å¦‚ï¼Œæƒ³è±¡ä¸€ä¸‹ä¸€ä¸ª jQuery æ ‡ç­¾é¢æ¿ï¼Œå®ƒä¼šå°†éæ´»åŠ¨æ ‡ç­¾ä» DOM ä¸­ç§»é™¤ã€‚å¦‚æœä¸€ä¸ªæ ‡ç­¾è¢«ç§»é™¤ï¼Œå…¶å†…éƒ¨çš„æ‰€æœ‰å†…å®¹ï¼ˆåŒ…æ‹¬å…¶ä¸­çš„ React æ ¹èŠ‚ç‚¹ï¼‰ä¹Ÿå°†ä» DOM ä¸­ç§»é™¤ã€‚ä½ éœ€è¦è°ƒç”¨ `root.unmount` æ¥å‘Šè¯‰ React â€œåœæ­¢â€ç®¡ç†å·²ç§»é™¤æ ¹èŠ‚ç‚¹çš„å†…å®¹ã€‚å¦åˆ™ï¼Œå·²ç§»é™¤æ ¹èŠ‚ç‚¹å†…çš„ç»„ä»¶å°†æ— æ³•æ¸…ç†å’Œé‡Šæ”¾å·²ä½¿ç”¨çš„èµ„æºï¼Œä¾‹å¦‚è®¢é˜…ã€‚

è°ƒç”¨ `root.unmount` å°†å¸è½½æ ¹èŠ‚ç‚¹ä¸­çš„æ‰€æœ‰ç»„ä»¶ï¼Œå¹¶â€œåˆ†ç¦»â€ React ä¸æ ¹ DOM èŠ‚ç‚¹ä¹‹é—´çš„è¿æ¥ï¼ŒåŒ…æ‹¬åˆ é™¤æ ‘ä¸­çš„ä»»ä½•äº‹ä»¶å¤„ç†ç¨‹åºæˆ–çŠ¶æ€ã€‚


#### å‚æ•° {/*root-unmount-parameters*/}


`root.unmount` ä¸æ¥å—ä»»ä½•å‚æ•°ã€‚

#### è¿”å›å€¼ {/*root-unmount-returns*/}

`render` è¿”å› `undefined` å€¼ã€‚

#### è­¦å‘Š {/*root-unmount-caveats*/}

* è°ƒç”¨ `root.unmount` å°†å¸è½½æ ‘ä¸­çš„æ‰€æœ‰ç»„ä»¶ï¼Œå¹¶â€œåˆ†ç¦»â€ React ä¸æ ¹ DOM èŠ‚ç‚¹ä¹‹é—´çš„è¿æ¥ã€‚

* ä¸€æ—¦ä½ è°ƒç”¨ `root.unmount`ï¼Œå°±ä¸èƒ½å†åœ¨æ ¹èŠ‚ç‚¹ä¸Šè°ƒç”¨ `root.render`ã€‚åœ¨æœªæŒ‚è½½çš„æ ¹èŠ‚ç‚¹ä¸Šå°è¯•è°ƒç”¨ `root.render` å°†æŠ›å‡ºâ€œä¸èƒ½æ›´æ–°æœªæŒ‚è½½çš„æ ¹èŠ‚ç‚¹â€çš„é”™è¯¯ã€‚

---

## ç”¨æ³• {/*usage*/}

### æ¿€æ´»æœåŠ¡ç«¯æ¸²æŸ“çš„ HTML {/*hydrating-server-rendered-html*/}

å¦‚æœä½ çš„åº”ç”¨ç¨‹åºçš„ HTML æ˜¯ç”± [`react-dom/server`](/reference/react-dom/client/createRoot) ç”Ÿæˆçš„ï¼Œä½ éœ€è¦åœ¨å®¢æˆ·ç«¯ä¸Šè¿›è¡Œ **hydrate**ã€‚

```js [[1, 3, "document.getElementById('root')"], [2, 3, "<App />"]]
import { hydrateRoot } from 'react-dom/client';

hydrateRoot(document.getElementById('root'), <App />);
```

å¯¹äºä½ çš„åº”ç”¨ç¨‹åºæ¥è¯´ï¼Œè¿™å°†æ¿€æ´»ä½ çš„æœåŠ¡ç«¯ HTML æ¥å¤è‹é‡Œé¢çš„ <CodeStep step={1}>æµè§ˆå™¨ DOM èŠ‚ç‚¹</CodeStep>å’Œ <CodeStep step={2}>React ç»„ä»¶</CodeStep>ã€‚é€šå¸¸ï¼Œä½ åªéœ€è¦åœ¨å¯åŠ¨æ—¶æ‰§è¡Œä¸€æ¬¡ã€‚å¦‚æœä½ ä½¿ç”¨æ¡†æ¶ï¼Œåˆ™å¯èƒ½ä¼šè‡ªåŠ¨åœ¨å¹•åæ‰§è¡Œæ­¤æ“ä½œã€‚

ä¸ºäº†è¿›è¡Œæ¿€æ´»ï¼ŒReact å°†æŠŠä½ çš„ç»„ä»¶é€»è¾‘è¿æ¥åˆ°æœåŠ¡å™¨ä¸Šç”Ÿæˆçš„åˆå§‹ HTML ä¸­ã€‚æ¿€æ´»å¯ä»¥å°†æ¥è‡ªæœåŠ¡å™¨çš„åˆå§‹ HTML å¿«ç…§è½¬æ¢ä¸ºåœ¨æµè§ˆå™¨ä¸­è¿è¡Œçš„å®Œå…¨å¯äº¤äº’åº”ç”¨ã€‚

<Sandpack>

```html public/index.html
<!--
  åœ¨ <div id="root">...</div> ä¸­çš„ HTML å†…å®¹
  ç”± react-dom/server ç”Ÿæˆ
-->
<div id="root"><h1>Hello, world!</h1><button>You clicked me <!-- -->0<!-- --> times</button></div>
```

```js src/index.js active
import './styles.css';
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(
  document.getElementById('root'),
  <App />
);
```

```js src/App.js
import { useState } from 'react';

export default function App() {
  return (
    <>
      <h1>Hello, world!</h1>
      <Counter />
    </>
  );
}

function Counter() {
  const [count, setCount] = useState(0);
  return (
    <button onClick={() => setCount(count + 1)}>
      You clicked me {count} times
    </button>
  );
}
```

</Sandpack>

ä½ ä¸éœ€è¦å†æ¬¡è°ƒç”¨ `hydrateRoot` æˆ–è€…åœ¨å…¶ä»–åœ°æ–¹è°ƒç”¨å®ƒã€‚ä»ç°åœ¨å¼€å§‹ï¼ŒReact å°†ç®¡ç†ä½ çš„åº”ç”¨ç¨‹åºçš„ DOMã€‚æƒ³è¦æ›´æ–° UI è¯·ä½¿ç”¨ [useState](/reference/react/useState) æ›¿ä»£ã€‚

<Pitfall>

ä¼ é€’ç»™ `hydrateRoot` çš„ React æ ‘å¿…é¡»ç”Ÿæˆä¸æœåŠ¡ç«¯ **ç›¸åŒçš„è¾“å‡º**ã€‚

è¿™å¯¹äºç”¨æˆ·ä½“éªŒéå¸¸é‡è¦ã€‚ç”¨æˆ·ä¼šåœ¨ä½ çš„ JavaScript ä»£ç åŠ è½½å‰èŠ±è´¹ä¸€äº›æ—¶é—´æ¥æŸ¥çœ‹æœåŠ¡ç«¯ç”Ÿæˆçš„ HTMLã€‚æœåŠ¡ç«¯æ¸²æŸ“é€šè¿‡æ˜¾ç¤ºåº”ç”¨è¾“å‡ºçš„ HTML å¿«ç…§æ¥äº§ç”Ÿäº†åº”ç”¨ç¨‹åºåŠ é€ŸåŠ è½½çš„é”™è§‰ã€‚çªç„¶å‡ºç°ä¸åŒçš„å†…å®¹ä¼šç ´åè¿™ç§é”™è§‰ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæœåŠ¡ç«¯æ¸²æŸ“è¾“å‡ºå¿…é¡»ä¸å®¢æˆ·ç«¯åˆå§‹æ¸²æŸ“è¾“å‡ºåŒ¹é…ã€‚

å¯¼è‡´æ¿€æ´»é”™è¯¯çš„æœ€å¸¸è§åŸå› åŒ…æ‹¬ï¼š

* æ ¹èŠ‚ç‚¹ React ç”Ÿæˆçš„ HTML å‘¨å›´å­˜åœ¨é¢å¤–çš„ç©ºç™½ç¬¦ï¼ˆå¦‚æ¢è¡Œç¬¦ï¼‰ã€‚
* åœ¨æ¸²æŸ“é€»è¾‘ä¸­ä½¿ç”¨ `typeof window !== 'undefined'` è¿™æ ·çš„åˆ¤æ–­ã€‚
* åœ¨æ¸²æŸ“é€»è¾‘ä¸­ä½¿ç”¨ä»…é™äºæµè§ˆå™¨ç«¯çš„ APIï¼Œä¾‹å¦‚ [`window.matchMedia`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia)ã€‚
* åœ¨æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯æ¸²æŸ“ä¸åŒçš„æ•°æ®ã€‚

React å¯ä»¥ä»ä¸€äº›æ¿€æ´»é”™è¯¯ä¸­æ¢å¤ï¼Œä½† **ä½ å¿…é¡»åƒå¤„ç†å…¶ä»– bug ä¸€æ ·ä¿®å¤å®ƒä»¬**ã€‚åœ¨æœ€å¥½çš„æƒ…å†µä¸‹ï¼Œå®ƒä»¬ä¼šå¯¼è‡´åº”ç”¨ç¨‹åºåŠ è½½å˜æ…¢ï¼›åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œäº‹ä»¶å¤„ç†ç¨‹åºå¯èƒ½ä¼šé™„åŠ åˆ°é”™è¯¯çš„å…ƒç´ ä¸Šã€‚

</Pitfall>

---

### æ¿€æ´»æ•´ä¸ªæ–‡æ¡£ {/*hydrating-an-entire-document*/}

å®Œå…¨ä½¿ç”¨ React æ„å»ºçš„åº”ç”¨ç¨‹åºå¯ä»¥å°†æ•´ä¸ªæ–‡æ¡£ä½œä¸º JSX æ¸²æŸ“ï¼ŒåŒ…æ‹¬ [`<html>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/html) æ ‡ç­¾ï¼š

```js {3,13}
function App() {
  return (
    <html>
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="/styles.css"></link>
        <title>My app</title>
      </head>
      <body>
        <Router />
      </body>
    </html>
  );
}
```

è¦å¯¹æ•´ä¸ªæ–‡æ¡£è¿›è¡Œæ¿€æ´»å¤„ç†ï¼Œå°†å…¨å±€çš„ [`document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/document) ä½œä¸º `hydrateRoot` çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¼ é€’ï¼š

```js {4}
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(document, <App />);
```

---

### æŠ‘åˆ¶ä¸å¯é¿å…çš„æ¿€æ´»å¤„ç†ä¸åŒ¹é…é”™è¯¯ {/*suppressing-unavoidable-hydration-mismatch-errors*/}

å¦‚æœä¸€ä¸ªå•ç‹¬å…ƒç´ å±æ€§æˆ–æ–‡æœ¬å†…å®¹åœ¨æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ä¹‹é—´æ˜¯ä¸å¯é¿å…åœ°ä¸åŒçš„ï¼ˆä¾‹å¦‚ï¼Œæ—¶é—´æˆ³ï¼‰ï¼Œåˆ™å¯ä»¥æŠ‘åˆ¶æ¿€æ´»å¤„ç†ä¸åŒ¹é…è­¦å‘Šã€‚

è¦æ¶ˆé™¤å¯¹å…ƒç´ çš„æ¿€æ´»å¤„ç†è­¦å‘Šï¼Œè¯·æ·»åŠ  `suppressHydrationWarning={true}`ï¼š

<Sandpack>

```html public/index.html
<!--
  åœ¨ <div id="root">...</div> ä¸­çš„ HTML å†…å®¹
  ç”± react-dom/server ç”Ÿæˆ
-->
<div id="root"><h1>Current Date: <!-- -->01/01/2020</h1></div>
```

```js src/index.js
import './styles.css';
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(document.getElementById('root'), <App />);
```

```js src/App.js active
export default function App() {
  return (
    <h1 suppressHydrationWarning={true}>
      Current Date: {new Date().toLocaleDateString()}
    </h1>
  );
}
```

</Sandpack>

æ­¤æ–¹æ³•ä»…é€‚ç”¨äºå½“å‰å±‚çº§ï¼Œå¹¶ä¸”æ—¨åœ¨ä½œä¸ºä¸€ç§è„±å›´æœºåˆ¶ã€‚ä¸è¦æ»¥ç”¨å®ƒã€‚é™¤éæ˜¯æ–‡æœ¬å†…å®¹ï¼Œå¦åˆ™ React ä¸ä¼šå°è¯•ä¿®è¡¥å®ƒï¼Œå› æ­¤å¯èƒ½ä¼šä¿æŒä¸ä¸€è‡´ï¼Œç›´åˆ°æœªæ¥çš„æ›´æ–°æ¥åˆ°ã€‚

---

### å¤„ç†ä¸åŒçš„å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯å†…å®¹ {/*handling-different-client-and-server-content*/}

å¦‚æœä½ æœ‰æ„åœ¨æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ä¸Šå‘ˆç°ä¸åŒçš„å†…å®¹ï¼Œåˆ™å¯ä»¥è¿›è¡Œä¸¤æ¬¡æ¸²æŸ“ã€‚åœ¨å®¢æˆ·ç«¯ä¸Šå‘ˆç°ä¸åŒå†…å®¹çš„ç»„ä»¶å¯ä»¥è¯»å–ç±»ä¼¼äº `isClient` çš„ [çŠ¶æ€å˜é‡](/reference/react/useState)ï¼Œä½ å¯ä»¥åœ¨ [Effect](/reference/react/useEffect) ä¸­å°†å…¶è®¾ç½®ä¸º `true`ï¼š

<Sandpack>

```html public/index.html
<!--
  åœ¨ <div id="root">...</div> ä¸­çš„ HTML å†…å®¹
  ç”± react-dom/server ç”Ÿæˆ
-->
<div id="root"><h1>Is Server</h1></div>
```

```js src/index.js
import './styles.css';
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(document.getElementById('root'), <App />);
```

```js src/App.js active
import { useState, useEffect } from "react";

export default function App() {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  return (
    <h1>
      {isClient ? 'Is Client' : 'Is Server'}
    </h1>
  );
}
```

</Sandpack>

è¿™æ ·ï¼Œåˆå§‹æ¸²æŸ“å°†å‘ˆç°ä¸æœåŠ¡å™¨ç›¸åŒçš„å†…å®¹ï¼Œé¿å…ä¸åŒ¹é…ï¼Œä½†æ˜¯åœ¨æ¿€æ´»ä¹‹åä¼šåŒæ­¥è¿›è¡Œé¢å¤–çš„æ¸²æŸ“ã€‚

<Pitfall>

è¿™ç§æ–¹æ³•ä½¿å¾—æ¿€æ´»å˜æ…¢ï¼Œå› ä¸ºä½ çš„ç»„ä»¶éœ€è¦æ¸²æŸ“ä¸¤æ¬¡ã€‚è¦æ³¨æ„åœ¨ç½‘ç»œè¿æ¥è¾ƒæ…¢çš„æƒ…å†µä¸‹ç”¨æˆ·çš„ä½“éªŒã€‚JavaScript ä»£ç çš„åŠ è½½æ—¶é—´å¯èƒ½ä¼šæ¯”åˆå§‹çš„ HTML æ¸²æŸ“æ…¢å¾ˆå¤šï¼Œå› æ­¤åœ¨æ¿€æ´»ä¹‹åç«‹å³å‘ˆç°ä¸åŒçš„ UI å¯¹ç”¨æˆ·æ¥è¯´å¯èƒ½ä¹Ÿä¼šæ„Ÿåˆ°ä¸é€‚ã€‚

</Pitfall>

---

### æ›´æ–°æ¿€æ´»æ ¹ç»„ä»¶ {/*updating-a-hydrated-root-component*/}

åœ¨æ ¹ç»„ä»¶æ¿€æ´»å®Œæˆä¹‹åï¼Œä½ å¯ä»¥è°ƒç”¨ [`root.render`](#root-render) æ¥æ›´æ–°æ ¹ React ç»„ä»¶ã€‚**ä¸  [`createRoot`](/reference/react-dom/client/createRoot) ä¸åŒçš„æ˜¯ï¼Œé€šå¸¸ä½ ä¸éœ€è¦è¿™æ ·åšï¼Œå› ä¸ºåˆå§‹å†…å®¹å·²ç»æ¸²æŸ“ä¸º HTML**ã€‚

å¦‚æœåœ¨æ¿€æ´»ä¹‹åæŸä¸ªæ—¶åˆ»è°ƒç”¨äº† `root.render`ï¼Œå¹¶ä¸”ç»„ä»¶æ ‘ç»“æ„ä¸ä¹‹å‰æ¸²æŸ“çš„ç›¸åŒ¹é…ï¼Œé‚£ä¹ˆ React å°† [ä¿ç•™é‡ç½® state](/learn/preserving-and-resetting-state)ã€‚è¯·æ³¨æ„ï¼Œä½ å¯ä»¥åœ¨è¾“å…¥æ¡†ä¸­è¾“å…¥æ–‡å­—ï¼Œè¿™æ„å‘³ç€åœ¨æ­¤ç¤ºä¾‹ä¸­æ¯ç§’é’Ÿé‡å¤è°ƒç”¨çš„ `render` ä¸ä¼šç ´åå·²æœ‰çš„ç»„ä»¶çŠ¶æ€ï¼š

<Sandpack>

```html public/index.html
<!--
  åœ¨ <div id="root">...</div> ä¸­çš„ HTML å†…å®¹
  ç”± react-dom/server ç”Ÿæˆ
-->
<div id="root"><h1>Hello, world! <!-- -->0</h1><input placeholder="Type something here"/></div>
```

```js src/index.js active
import { hydrateRoot } from 'react-dom/client';
import './styles.css';
import App from './App.js';

const root = hydrateRoot(
  document.getElementById('root'),
  <App counter={0} />
);

let i = 0;
setInterval(() => {
  root.render(<App counter={i} />);
  i++;
}, 1000);
```

```js src/App.js
export default function App({counter}) {
  return (
    <>
      <h1>Hello, world! {counter}</h1>
      <input placeholder="Type something here" />
    </>
  );
}
```

</Sandpack>

It is uncommon to call [`root.render`](#root-render) on a hydrated root. Usually, you'll [update state](/reference/react/useState) inside one of the components instead.

### Show a dialog for uncaught errors {/*show-a-dialog-for-uncaught-errors*/}

By default, React will log all uncaught errors to the console. To implement your own error reporting, you can provide the optional `onUncaughtError` root option:

```js [[1, 7, "onUncaughtError"], [2, 7, "error", 1], [3, 7, "errorInfo"], [4, 11, "componentStack"]]
import { hydrateRoot } from 'react-dom/client';

const root = hydrateRoot(
  document.getElementById('root'),
  <App />,
  {
    onUncaughtError: (error, errorInfo) => {
      console.error(
        'Uncaught error',
        error,
        errorInfo.componentStack
      );
    }
  }
);
root.render(<App />);
```

The <CodeStep step={1}>onUncaughtError</CodeStep> option is a function called with two arguments:

1. The <CodeStep step={2}>error</CodeStep> that was thrown.
2. An <CodeStep step={3}>errorInfo</CodeStep> object that contains the <CodeStep step={4}>componentStack</CodeStep> of the error.

You can use the `onUncaughtError` root option to display error dialogs:

<Sandpack>

```html public/index.html hidden
<!DOCTYPE html>
<html>
<head>
  <title>My app</title>
</head>
<body>
<!--
  Error dialog in raw HTML
  since an error in the React app may crash.
-->
<div id="error-dialog" class="hidden">
  <h1 id="error-title" class="text-red"></h1>
  <h3>
    <pre id="error-message"></pre>
  </h3>
  <p>
    <pre id="error-body"></pre>
  </p>
  <h4 class="-mb-20">This error occurred at:</h4>
  <pre id="error-component-stack" class="nowrap"></pre>
  <h4 class="mb-0">Call stack:</h4>
  <pre id="error-stack" class="nowrap"></pre>
  <div id="error-cause">
    <h4 class="mb-0">Caused by:</h4>
    <pre id="error-cause-message"></pre>
    <pre id="error-cause-stack" class="nowrap"></pre>
  </div>
  <button
    id="error-close"
    class="mb-10"
    onclick="document.getElementById('error-dialog').classList.add('hidden')"
  >
    Close
  </button>
  <h3 id="error-not-dismissible">This error is not dismissible.</h3>
</div>
<!--
  HTML content inside <div id="root">...</div>
  was generated from App by react-dom/server.
-->
<div id="root"><div><span>This error shows the error dialog:</span><button>Throw error</button></div></div>
</body>
</html>
```

```css src/styles.css active
label, button { display: block; margin-bottom: 20px; }
html, body { min-height: 300px; }

#error-dialog {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: white;
  padding: 15px;
  opacity: 0.9;
  text-wrap: wrap;
  overflow: scroll;
}

.text-red {
  color: red;
}

.-mb-20 {
  margin-bottom: -20px;
}

.mb-0 {
  margin-bottom: 0;
}

.mb-10 {
  margin-bottom: 10px;
}

pre {
  text-wrap: wrap;
}

pre.nowrap {
  text-wrap: nowrap;
}

.hidden {
 display: none;  
}
```

```js src/reportError.js hidden
function reportError({ title, error, componentStack, dismissable }) {
  const errorDialog = document.getElementById("error-dialog");
  const errorTitle = document.getElementById("error-title");
  const errorMessage = document.getElementById("error-message");
  const errorBody = document.getElementById("error-body");
  const errorComponentStack = document.getElementById("error-component-stack");
  const errorStack = document.getElementById("error-stack");
  const errorClose = document.getElementById("error-close");
  const errorCause = document.getElementById("error-cause");
  const errorCauseMessage = document.getElementById("error-cause-message");
  const errorCauseStack = document.getElementById("error-cause-stack");
  const errorNotDismissible = document.getElementById("error-not-dismissible");
  
  // Set the title
  errorTitle.innerText = title;
  
  // Display error message and body
  const [heading, body] = error.message.split(/\n(.*)/s);
  errorMessage.innerText = heading;
  if (body) {
    errorBody.innerText = body;
  } else {
    errorBody.innerText = '';
  }

  // Display component stack
  errorComponentStack.innerText = componentStack;

  // Display the call stack
  // Since we already displayed the message, strip it, and the first Error: line.
  errorStack.innerText = error.stack.replace(error.message, '').split(/\n(.*)/s)[1];
  
  // Display the cause, if available
  if (error.cause) {
    errorCauseMessage.innerText = error.cause.message;
    errorCauseStack.innerText = error.cause.stack;
    errorCause.classList.remove('hidden');
  } else {
    errorCause.classList.add('hidden');
  }
  // Display the close button, if dismissible
  if (dismissable) {
    errorNotDismissible.classList.add('hidden');
    errorClose.classList.remove("hidden");
  } else {
    errorNotDismissible.classList.remove('hidden');
    errorClose.classList.add("hidden");
  }
  
  // Show the dialog
  errorDialog.classList.remove("hidden");
}

export function reportCaughtError({error, cause, componentStack}) {
  reportError({ title: "Caught Error", error, componentStack,  dismissable: true});
}

export function reportUncaughtError({error, cause, componentStack}) {
  reportError({ title: "Uncaught Error", error, componentStack, dismissable: false });
}

export function reportRecoverableError({error, cause, componentStack}) {
  reportError({ title: "Recoverable Error", error, componentStack,  dismissable: true });
}
```

```js src/index.js active
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";
import {reportUncaughtError} from "./reportError";
import "./styles.css";
import {renderToString} from 'react-dom/server';

const container = document.getElementById("root");
const root = hydrateRoot(container, <App />, {
  onUncaughtError: (error, errorInfo) => {
    if (error.message !== 'Known error') {
      reportUncaughtError({
        error,
        componentStack: errorInfo.componentStack
      });
    }
  }
});
```

```js src/App.js
import { useState } from 'react';

export default function App() {
  const [throwError, setThrowError] = useState(false);
  
  if (throwError) {
    foo.bar = 'baz';
  }
  
  return (
    <div>
      <span>This error shows the error dialog:</span>
      <button onClick={() => setThrowError(true)}>
        Throw error
      </button>
    </div>
  );
}
```

</Sandpack>


### Displaying Error Boundary errors {/*displaying-error-boundary-errors*/}

By default, React will log all errors caught by an Error Boundary to `console.error`. To override this behavior, you can provide the optional `onCaughtError` root option for errors caught by an [Error Boundary](/reference/react/Component#catching-rendering-errors-with-an-error-boundary):

```js [[1, 7, "onCaughtError"], [2, 7, "error", 1], [3, 7, "errorInfo"], [4, 11, "componentStack"]]
import { hydrateRoot } from 'react-dom/client';

const root = hydrateRoot(
  document.getElementById('root'),
  <App />,
  {
    onCaughtError: (error, errorInfo) => {
      console.error(
        'Caught error',
        error,
        errorInfo.componentStack
      );
    }
  }
);
root.render(<App />);
```

The <CodeStep step={1}>onCaughtError</CodeStep> option is a function called with two arguments:

1. The <CodeStep step={2}>error</CodeStep> that was caught by the boundary.
2. An <CodeStep step={3}>errorInfo</CodeStep> object that contains the <CodeStep step={4}>componentStack</CodeStep> of the error.

You can use the `onCaughtError` root option to display error dialogs or filter known errors from logging:

<Sandpack>

```html public/index.html hidden
<!DOCTYPE html>
<html>
<head>
  <title>My app</title>
</head>
<body>
<!--
  Error dialog in raw HTML
  since an error in the React app may crash.
-->
<div id="error-dialog" class="hidden">
  <h1 id="error-title" class="text-red"></h1>
  <h3>
    <pre id="error-message"></pre>
  </h3>
  <p>
    <pre id="error-body"></pre>
  </p>
  <h4 class="-mb-20">This error occurred at:</h4>
  <pre id="error-component-stack" class="nowrap"></pre>
  <h4 class="mb-0">Call stack:</h4>
  <pre id="error-stack" class="nowrap"></pre>
  <div id="error-cause">
    <h4 class="mb-0">Caused by:</h4>
    <pre id="error-cause-message"></pre>
    <pre id="error-cause-stack" class="nowrap"></pre>
  </div>
  <button
    id="error-close"
    class="mb-10"
    onclick="document.getElementById('error-dialog').classList.add('hidden')"
  >
    Close
  </button>
  <h3 id="error-not-dismissible">This error is not dismissible.</h3>
</div>
<!--
  HTML content inside <div id="root">...</div>
  was generated from App by react-dom/server.
-->
<div id="root"><span>This error will not show the error dialog:</span><button>Throw known error</button><span>This error will show the error dialog:</span><button>Throw unknown error</button></div>
</body>
</html>
```

```css src/styles.css active
label, button { display: block; margin-bottom: 20px; }
html, body { min-height: 300px; }

#error-dialog {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: white;
  padding: 15px;
  opacity: 0.9;
  text-wrap: wrap;
  overflow: scroll;
}

.text-red {
  color: red;
}

.-mb-20 {
  margin-bottom: -20px;
}

.mb-0 {
  margin-bottom: 0;
}

.mb-10 {
  margin-bottom: 10px;
}

pre {
  text-wrap: wrap;
}

pre.nowrap {
  text-wrap: nowrap;
}

.hidden {
 display: none;  
}
```

```js src/reportError.js hidden
function reportError({ title, error, componentStack, dismissable }) {
  const errorDialog = document.getElementById("error-dialog");
  const errorTitle = document.getElementById("error-title");
  const errorMessage = document.getElementById("error-message");
  const errorBody = document.getElementById("error-body");
  const errorComponentStack = document.getElementById("error-component-stack");
  const errorStack = document.getElementById("error-stack");
  const errorClose = document.getElementById("error-close");
  const errorCause = document.getElementById("error-cause");
  const errorCauseMessage = document.getElementById("error-cause-message");
  const errorCauseStack = document.getElementById("error-cause-stack");
  const errorNotDismissible = document.getElementById("error-not-dismissible");
  
  // Set the title
  errorTitle.innerText = title;
  
  // Display error message and body
  const [heading, body] = error.message.split(/\n(.*)/s);
  errorMessage.innerText = heading;
  if (body) {
    errorBody.innerText = body;
  } else {
    errorBody.innerText = '';
  }

  // Display component stack
  errorComponentStack.innerText = componentStack;

  // Display the call stack
  // Since we already displayed the message, strip it, and the first Error: line.
  errorStack.innerText = error.stack.replace(error.message, '').split(/\n(.*)/s)[1];
  
  // Display the cause, if available
  if (error.cause) {
    errorCauseMessage.innerText = error.cause.message;
    errorCauseStack.innerText = error.cause.stack;
    errorCause.classList.remove('hidden');
  } else {
    errorCause.classList.add('hidden');
  }
  // Display the close button, if dismissible
  if (dismissable) {
    errorNotDismissible.classList.add('hidden');
    errorClose.classList.remove("hidden");
  } else {
    errorNotDismissible.classList.remove('hidden');
    errorClose.classList.add("hidden");
  }
  
  // Show the dialog
  errorDialog.classList.remove("hidden");
}

export function reportCaughtError({error, cause, componentStack}) {
  reportError({ title: "Caught Error", error, componentStack,  dismissable: true});
}

export function reportUncaughtError({error, cause, componentStack}) {
  reportError({ title: "Uncaught Error", error, componentStack, dismissable: false });
}

export function reportRecoverableError({error, cause, componentStack}) {
  reportError({ title: "Recoverable Error", error, componentStack,  dismissable: true });
}
```

```js src/index.js active
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";
import {reportCaughtError} from "./reportError";
import "./styles.css";

const container = document.getElementById("root");
const root = hydrateRoot(container, <App />, {
  onCaughtError: (error, errorInfo) => {
    if (error.message !== 'Known error') {
      reportCaughtError({
        error,
        componentStack: errorInfo.componentStack
      });
    }
  }
});
```

```js src/App.js
import { useState } from 'react';
import { ErrorBoundary } from "react-error-boundary";

export default function App() {
  const [error, setError] = useState(null);
  
  function handleUnknown() {
    setError("unknown");
  }

  function handleKnown() {
    setError("known");
  }
  
  return (
    <>
      <ErrorBoundary
        fallbackRender={fallbackRender}
        onReset={(details) => {
          setError(null);
        }}
      >
        {error != null && <Throw error={error} />}
        <span>This error will not show the error dialog:</span>
        <button onClick={handleKnown}>
          Throw known error
        </button>
        <span>This error will show the error dialog:</span>
        <button onClick={handleUnknown}>
          Throw unknown error
        </button>
      </ErrorBoundary>
      
    </>
  );
}

function fallbackRender({ resetErrorBoundary }) {
  return (
    <div role="alert">
      <h3>Error Boundary</h3>
      <p>Something went wrong.</p>
      <button onClick={resetErrorBoundary}>Reset</button>
    </div>
  );
}

function Throw({error}) {
  if (error === "known") {
    throw new Error('Known error')
  } else {
    foo.bar = 'baz';
  }
}
```

```json package.json hidden
{
  "dependencies": {
    "react": "19.0.0-rc-3edc000d-20240926",
    "react-dom": "19.0.0-rc-3edc000d-20240926",
    "react-scripts": "^5.0.0",
    "react-error-boundary": "4.0.3"
  },
  "main": "/index.js"
}
```

</Sandpack>

### Show a dialog for recoverable hydration mismatch errors {/*show-a-dialog-for-recoverable-hydration-mismatch-errors*/}

When React encounters a hydration mismatch, it will automatically attempt to recover by rendering on the client. By default, React will log hydration mismatch errors to `console.error`. To override this behavior, you can provide the optional `onRecoverableError` root option:

```js [[1, 7, "onRecoverableError"], [2, 7, "error", 1], [3, 11, "error.cause", 1], [4, 7, "errorInfo"], [5, 12, "componentStack"]]
import { hydrateRoot } from 'react-dom/client';

const root = hydrateRoot(
  document.getElementById('root'),
  <App />,
  {
    onRecoverableError: (error, errorInfo) => {
      console.error(
        'Caught error',
        error,
        error.cause,
        errorInfo.componentStack
      );
    }
  }
);
```

The <CodeStep step={1}>onRecoverableError</CodeStep> option is a function called with two arguments:

1. The <CodeStep step={2}>error</CodeStep> React throws. Some errors may include the original cause as <CodeStep step={3}>error.cause</CodeStep>.
2. An <CodeStep step={4}>errorInfo</CodeStep> object that contains the <CodeStep step={5}>componentStack</CodeStep> of the error.

You can use the `onRecoverableError` root option to display error dialogs for hydration mismatches:

<Sandpack>

```html public/index.html hidden
<!DOCTYPE html>
<html>
<head>
  <title>My app</title>
</head>
<body>
<!--
  Error dialog in raw HTML
  since an error in the React app may crash.
-->
<div id="error-dialog" class="hidden">
  <h1 id="error-title" class="text-red"></h1>
  <h3>
    <pre id="error-message"></pre>
  </h3>
  <p>
    <pre id="error-body"></pre>
  </p>
  <h4 class="-mb-20">This error occurred at:</h4>
  <pre id="error-component-stack" class="nowrap"></pre>
  <h4 class="mb-0">Call stack:</h4>
  <pre id="error-stack" class="nowrap"></pre>
  <div id="error-cause">
    <h4 class="mb-0">Caused by:</h4>
    <pre id="error-cause-message"></pre>
    <pre id="error-cause-stack" class="nowrap"></pre>
  </div>
  <button
    id="error-close"
    class="mb-10"
    onclick="document.getElementById('error-dialog').classList.add('hidden')"
  >
    Close
  </button>
  <h3 id="error-not-dismissible">This error is not dismissible.</h3>
</div>
<!--
  HTML content inside <div id="root">...</div>
  was generated from App by react-dom/server.
-->
<div id="root"><span>Server</span></div>
</body>
</html>
```

```css src/styles.css active
label, button { display: block; margin-bottom: 20px; }
html, body { min-height: 300px; }

#error-dialog {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: white;
  padding: 15px;
  opacity: 0.9;
  text-wrap: wrap;
  overflow: scroll;
}

.text-red {
  color: red;
}

.-mb-20 {
  margin-bottom: -20px;
}

.mb-0 {
  margin-bottom: 0;
}

.mb-10 {
  margin-bottom: 10px;
}

pre {
  text-wrap: wrap;
}

pre.nowrap {
  text-wrap: nowrap;
}

.hidden {
 display: none;  
}
```

```js src/reportError.js hidden
function reportError({ title, error, componentStack, dismissable }) {
  const errorDialog = document.getElementById("error-dialog");
  const errorTitle = document.getElementById("error-title");
  const errorMessage = document.getElementById("error-message");
  const errorBody = document.getElementById("error-body");
  const errorComponentStack = document.getElementById("error-component-stack");
  const errorStack = document.getElementById("error-stack");
  const errorClose = document.getElementById("error-close");
  const errorCause = document.getElementById("error-cause");
  const errorCauseMessage = document.getElementById("error-cause-message");
  const errorCauseStack = document.getElementById("error-cause-stack");
  const errorNotDismissible = document.getElementById("error-not-dismissible");
  
  // Set the title
  errorTitle.innerText = title;
  
  // Display error message and body
  const [heading, body] = error.message.split(/\n(.*)/s);
  errorMessage.innerText = heading;
  if (body) {
    errorBody.innerText = body;
  } else {
    errorBody.innerText = '';
  }

  // Display component stack
  errorComponentStack.innerText = componentStack;

  // Display the call stack
  // Since we already displayed the message, strip it, and the first Error: line.
  errorStack.innerText = error.stack.replace(error.message, '').split(/\n(.*)/s)[1];
  
  // Display the cause, if available
  if (error.cause) {
    errorCauseMessage.innerText = error.cause.message;
    errorCauseStack.innerText = error.cause.stack;
    errorCause.classList.remove('hidden');
  } else {
    errorCause.classList.add('hidden');
  }
  // Display the close button, if dismissible
  if (dismissable) {
    errorNotDismissible.classList.add('hidden');
    errorClose.classList.remove("hidden");
  } else {
    errorNotDismissible.classList.remove('hidden');
    errorClose.classList.add("hidden");
  }
  
  // Show the dialog
  errorDialog.classList.remove("hidden");
}

export function reportCaughtError({error, cause, componentStack}) {
  reportError({ title: "Caught Error", error, componentStack,  dismissable: true});
}

export function reportUncaughtError({error, cause, componentStack}) {
  reportError({ title: "Uncaught Error", error, componentStack, dismissable: false });
}

export function reportRecoverableError({error, cause, componentStack}) {
  reportError({ title: "Recoverable Error", error, componentStack,  dismissable: true });
}
```

```js src/index.js active
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";
import {reportRecoverableError} from "./reportError";
import "./styles.css";

const container = document.getElementById("root");
const root = hydrateRoot(container, <App />, {
  onRecoverableError: (error, errorInfo) => {
    reportRecoverableError({
      error,
      cause: error.cause,
      componentStack: errorInfo.componentStack
    });
  }
});
```

```js src/App.js
import { useState } from 'react';
import { ErrorBoundary } from "react-error-boundary";

export default function App() {
  const [error, setError] = useState(null);
  
  function handleUnknown() {
    setError("unknown");
  }

  function handleKnown() {
    setError("known");
  }
  
  return (
    <span>{typeof window !== 'undefined' ? 'Client' : 'Server'}</span>
  );
}

function fallbackRender({ resetErrorBoundary }) {
  return (
    <div role="alert">
      <h3>Error Boundary</h3>
      <p>Something went wrong.</p>
      <button onClick={resetErrorBoundary}>Reset</button>
    </div>
  );
}

function Throw({error}) {
  if (error === "known") {
    throw new Error('Known error')
  } else {
    foo.bar = 'baz';
  }
}
```

```json package.json hidden
{
  "dependencies": {
    "react": "19.0.0-rc-3edc000d-20240926",
    "react-dom": "19.0.0-rc-3edc000d-20240926",
    "react-scripts": "^5.0.0",
    "react-error-boundary": "4.0.3"
  },
  "main": "/index.js"
}
```

</Sandpack>

## Troubleshooting {/*troubleshooting*/}


### I'm getting an error: "You passed a second argument to root.render" {/*im-getting-an-error-you-passed-a-second-argument-to-root-render*/}

A common mistake is to pass the options for `hydrateRoot` to `root.render(...)`:

<ConsoleBlock level="error">

Warning: You passed a second argument to root.render(...) but it only accepts one argument.

</ConsoleBlock>

To fix, pass the root options to `hydrateRoot(...)`, not `root.render(...)`:
```js {2,5}
// ğŸš© Wrong: root.render only takes one argument.
root.render(App, {onUncaughtError});

// âœ… Correct: pass options to createRoot.
const root = hydrateRoot(container, <App />, {onUncaughtError});
```
